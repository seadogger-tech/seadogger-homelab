- name: Jellyfin deploy (bjw-s/app-template) â€” tasks-only
  vars:
    kubeconfig_path: /etc/rancher/k3s/k3s.yaml
    jellyfin_namespace: jellyfin
    argocd_namespace: argocd

    pv_name:  jellyfin-nextcloud-media-ro
    pvc_name: jellyfin-media-ro

    helm_repo_url: "https://bjw-s-labs.github.io/helm-charts"
    helm_chart: "app-template"
    helm_version: "4.3.0"
    values_url: "https://raw.githubusercontent.com/seadogger-tech/seadogger-homelab/master/deployments/jellyfin/jellyfin-values.yaml"

    ingress_url: "https://raw.githubusercontent.com/seadogger-tech/seadogger-homelab/master/ingress/traefik-jellyfin-ingress.yml"
  block:
    - name: Ensure jellyfin namespace exists (you deleted it earlier)
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ jellyfin_namespace }}"

    - name: Read current static PV
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig_path }}"
        api_version: v1
        kind: PersistentVolume
        name: "{{ pv_name }}"
      register: pv_info

    - name: Clear claimRef if PV is Released (enables new binding)
      ansible.builtin.command:
        cmd: >
          kubectl patch pv {{ pv_name }} --type=json
          -p='[{"op":"remove","path":"/spec/claimRef"}]'
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      when:
        - pv_info.resources | length > 0
        - pv_info.resources[0].status.phase == "Released"
        - pv_info.resources[0].spec.claimRef is defined
      changed_when: true
      failed_when: false

    - name: Apply RO PVC (binds to {{ pv_name }})
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        definition:
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: "{{ pvc_name }}"
            namespace: "{{ jellyfin_namespace }}"
          spec:
            accessModes: ["ReadOnlyMany"]
            resources: { requests: { storage: 1Gi } }
            storageClassName: ""
            volumeName: "{{ pv_name }}"

    - name: Create/Update ArgoCD Application (bjw-s/app-template)
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        definition:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: jellyfin
            namespace: "{{ argocd_namespace }}"
          spec:
            project: default
            source:
              repoURL: "{{ helm_repo_url }}"
              chart: "{{ helm_chart }}"
              targetRevision: "{{ helm_version }}"
              helm:
                valueFiles: ["{{ values_url }}"]
            destination:
              server: https://kubernetes.default.svc
              namespace: "{{ jellyfin_namespace }}"
            syncPolicy:
              automated: { prune: true, selfHeal: true }
              syncOptions: ["CreateNamespace=true"]

    - name: Wait for Argo app to be Healthy
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig_path }}"
        api_version: argoproj.io/v1alpha1
        kind: Application
        name: jellyfin
        namespace: "{{ argocd_namespace }}"
      register: app
      retries: 30
      delay: 10
      until: app.resources and app.resources[0].status.health.status == "Healthy"

    - name: Fetch IngressRoutes manifest (remote)
      ansible.builtin.get_url:
        url: "{{ ingress_url }}"
        dest: "/tmp/traefik-jellyfin-ingress.yml"
        mode: "0644"

    - name: Apply IngressRoutes
      kubernetes.core.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        src: "/tmp/traefik-jellyfin-ingress.yml"
