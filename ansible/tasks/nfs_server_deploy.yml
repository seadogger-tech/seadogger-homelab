---
# Step 1: Set KUBECONFIG globally  
- name: Set KUBECONFIG global
  ansible.builtin.set_fact:
    KUBECONFIG: /etc/rancher/k3s/k3s.yaml

# Step 2: Delete existing NFS server namespace if it exists
- name: Delete existing NFS server namespace
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: absent
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: nfs-server
  ignore_errors: true

# Step 3: Poll until NFS server namespace is fully deleted
- name: Poll until NFS server namespace is fully deleted
  community.kubernetes.k8s_info:
    api_version: v1
    kind: Namespace
    name: nfs-server
    kubeconfig: "{{ KUBECONFIG }}"
  register: ns_poll
  until: ns_poll.resources is defined and ns_poll.resources | length == 0
  retries: 30
  delay: 10
  ignore_errors: true

# Step 4: Create new NFS server namespace
- name: Create NFS server namespace
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: nfs-server

# Step 5: Create ArgoCD NFS Server Application
- name: Create NFS Server ArgoCD Application
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: nfs-server
        namespace: argocd
      spec:
        project: default
        source:
          chart: nfs-server-provisioner
          repoURL: https://kubernetes-sigs.github.io/nfs-ganesha-server-and-external-provisioner
          targetRevision: 1.8.0
          helm:
            valueFiles:
              - https://raw.githubusercontent.com/seadogger/seadogger-homelab/master/helm-deployments/nfs-server/nfs-server-values.yaml
        destination:
          server: https://kubernetes.default.svc
          namespace: nfs-server
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
          syncOptions:
            - CreateNamespace=true

# Step 6: Wait for NFS server application to be healthy
- name: Wait for NFS server application to be healthy
  community.kubernetes.k8s_info:
    api_version: argoproj.io/v1alpha1
    kind: Application
    name: nfs-server
    namespace: argocd
    kubeconfig: "{{ KUBECONFIG }}"
  register: nfs_status
  until: nfs_status.resources is defined and
         nfs_status.resources[0].status.health.status is defined and
         nfs_status.resources[0].status.health.status == "Healthy"
  retries: 30
  delay: 10

# Step 7: Create LoadBalancer Service for NFS Server
- name: Create NFS Server LoadBalancer Service
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: Service
      metadata:
        name: nfs-server-loadbalancer
        namespace: nfs-server
        annotations:
          metallb.universe.tf/loadBalancerIPs: "192.168.1.253"
      spec:
        type: LoadBalancer
        selector:
          app: nfs-server-provisioner
          release: nfs-server
        ports:
        - name: nfs
          port: 2049
          protocol: TCP
          targetPort: nfs
        - name: nfs-udp
          port: 2049
          protocol: UDP
          targetPort: nfs-udp
        - name: nlockmgr
          port: 32803
          protocol: TCP
          targetPort: nlockmgr
        - name: nlockmgr-udp
          port: 32803
          protocol: UDP
          targetPort: nlockmgr-udp
        - name: mountd
          port: 20048
          protocol: TCP
          targetPort: mountd
        - name: mountd-udp
          port: 20048
          protocol: UDP
          targetPort: mountd-udp
        - name: rquotad
          port: 875
          protocol: TCP
          targetPort: rquotad
        - name: rquotad-udp
          port: 875
          protocol: UDP
          targetPort: rquotad-udp
        - name: rpcbind
          port: 111
          protocol: TCP
          targetPort: rpcbind
        - name: rpcbind-udp
          port: 111
          protocol: UDP
          targetPort: rpcbind-udp
        - name: statd
          port: 662
          protocol: TCP
          targetPort: statd
        - name: statd-udp
          port: 662
          protocol: UDP
          targetPort: statd-udp

# Step 8: Create ConfigMap for NFS Exports
- name: Create NFS Exports ConfigMap
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: nfs-exports
        namespace: nfs-server
      data:
        exports: |
          /shared 192.168.1.0/24(rw,sync,no_subtree_check,no_root_squash)

# Step 9: Patch StatefulSet to use NFS Exports ConfigMap and Create Shared Directory
- name: Patch NFS Server StatefulSet with Exports and Shared Directory
  ansible.builtin.shell: |
    kubectl patch statefulset nfs-server-nfs-server-provisioner -n nfs-server \
      -p '{"spec":{"template":{"spec":{"initContainers":[{"name":"init-shared-dir","image":"busybox","command":["sh","-c","mkdir -p /export/shared && chown -R 65534:65534 /export/shared"],"volumeMounts":[{"name":"export","mountPath":"/export"}]}],"volumes":[{"name":"exports","configMap":{"name":"nfs-exports"}}],"containers":[{"name":"nfs-server-provisioner","volumeMounts":[{"name":"exports","mountPath":"/etc/exports","subPath":"exports"}]}]}}}}'
  args:
    executable: /bin/bash
  environment:
    KUBECONFIG: "{{ KUBECONFIG }}"
