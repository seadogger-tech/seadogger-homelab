---
# Step 1: Set KUBECONFIG globally
- name: Set KUBECONFIG global
  ansible.builtin.set_fact:
    KUBECONFIG: /etc/rancher/k3s/k3s.yaml


# Step 3: Create new Prometheus namespace
- name: Create Prometheus namespace
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: monitoring

# Step 4: Apply Prometheus CRDs
- name: Apply Prometheus CRDs
  ansible.builtin.shell: >
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0alertmanagerCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0podmonitorCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0prometheusCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0prometheusruleCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0servicemonitorCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0thanosrulerCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0probeCustomResourceDefinition.yaml &&
    kubectl apply --server-side -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/release-0.13/manifests/setup/0alertmanagerConfigCustomResourceDefinition.yaml

- name: Wait for Prometheus CRDs to be established
  community.kubernetes.k8s_info:
    kubeconfig: "{{ KUBECONFIG }}"
    kind: CustomResourceDefinition
    name: "{{ item }}"
  register: crd_status
  until: crd_status.resources | default([]) | length > 0 and (crd_status.resources[0].status.conditions | selectattr('type', 'equalto', 'Established') | first).status == 'True'
  retries: 10
  delay: 5
  with_items:
    - alertmanagers.monitoring.coreos.com
    - podmonitors.monitoring.coreos.com
    - prometheuses.monitoring.coreos.com
    - prometheusrules.monitoring.coreos.com
    - servicemonitors.monitoring.coreos.com
    - thanosrulers.monitoring.coreos.com
    - probes.monitoring.coreos.com
    - alertmanagerconfigs.monitoring.coreos.com

# Step 5: Create Prometheus Stack ArgoCD Application
- name: Create Prometheus Stack ArgoCD Application
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: argoproj.io/v1alpha1
      kind: Application
      metadata:
        name: prometheus-stack
        namespace: argocd
      spec:
        project: default
        source:
          repoURL: https://github.com/prometheus-operator/kube-prometheus
          targetRevision: release-0.13
          path: manifests
        destination:
          server: https://kubernetes.default.svc
          namespace: monitoring
        syncPolicy:
          automated:
            prune: true
            selfHeal: true
          syncOptions:
            - CreateNamespace=true

# Step 5: Create LoadBalancer Services
- name: Create Prometheus LoadBalancer Service
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: Service
      metadata:
        name: prometheus-k8s-lb
        namespace: monitoring
      spec:
        type: LoadBalancer
        loadBalancerIP: "192.168.1.244"
        ports:
        - port: 9090
          targetPort: 9090
          protocol: TCP
        selector:
          app.kubernetes.io/name: prometheus
          prometheus: k8s

- name: Create Grafana LoadBalancer Service
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: Service
      metadata:
        name: grafana-lb
        namespace: monitoring
      spec:
        type: LoadBalancer
        loadBalancerIP: "192.168.1.245"
        ports:
        - port: 3000
          targetPort: 3000
          protocol: TCP
        selector:
          app.kubernetes.io/name: grafana

- name: Create Alertmanager LoadBalancer Service
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: v1
      kind: Service
      metadata:
        name: alertmanager-main-lb
        namespace: monitoring
      spec:
        type: LoadBalancer
        loadBalancerIP: "192.168.1.246"
        ports:
        - port: 9093
          targetPort: 9093
          protocol: TCP
        selector:
          app.kubernetes.io/name: alertmanager
          alertmanager: main

# Step 6: Create Network Policies for External Access
- name: Create Prometheus External Access Network Policy
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        name: allow-prometheus-external
        namespace: monitoring
      spec:
        podSelector:
          matchLabels:
            app.kubernetes.io/name: prometheus
        policyTypes:
          - Ingress
        ingress:
          - ports:
              - port: 9090

- name: Create Grafana External Access Network Policy
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        name: allow-grafana-external
        namespace: monitoring
      spec:
        podSelector:
          matchLabels:
            app.kubernetes.io/name: grafana
        policyTypes:
          - Ingress
        ingress:
          - ports:
              - port: 3000

- name: Create Alertmanager External Access Network Policy
  ansible.builtin.k8s:
    kubeconfig: "{{ KUBECONFIG }}"
    state: present
    definition:
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        name: allow-alertmanager-external
        namespace: monitoring
      spec:
        podSelector:
          matchLabels:
            app.kubernetes.io/name: alertmanager
        policyTypes:
          - Ingress
        ingress:
          - ports:
              - port: 9093

# Step 7: Wait for Prometheus Stack to be healthy
- name: Wait for prometheus-stack ArgoCD app to be healthy
  community.kubernetes.k8s_info:
    kubeconfig: "{{ KUBECONFIG }}"
    api_version: argoproj.io/v1alpha1
    kind: Application
    namespace: argocd
    name: prometheus-stack
  register: prometheus_status
  until: >
    prometheus_status.resources | default([]) | length > 0 and
    (prometheus_status.resources[0].status | default({})).get('health', {}).get('status', '') == 'Healthy'
  retries: 60
  delay: 10
